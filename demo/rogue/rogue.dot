digraph rogue_port {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust compiled to WebAssembly, playable in a browser. The original C source is at demo/rogue/original-rogue/ — about 16,800 lines across 33 files. The deliverable is a single HTML page at demo/rogue/rogue-wasm/www/index.html with classic ASCII terminal rendering: 80x24 grid, @ player, # corridors, monster letters A-Z, dark background, monospace font. This must be an exact mechanical port — same dungeon generation algorithms, same monster stats and AI, same item tables, same RNG formula, same combat math — a faithful 1:1 translation of every game system. ncurses I/O gets replaced by a WASM bridge to a JS terminal renderer, and save/load uses localStorage instead of the filesystem.",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement_fanout",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
            .hard { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
            .verify { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
            .branch-a { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
            .branch-b { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
            .branch-c { llm_model: gemini-3.0-flash-preview; llm_provider: google; }
        "
    ]

    exit  [shape=Msquare, label="Exit"]

    subgraph cluster_bootstrap {
        label="Bootstrap"
        start [shape=Mdiamond, label="Start"]

        check_toolchain [
            shape=parallelogram,
            max_retries=0,
            tool_command="/Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/rustc --version && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo --version && /Users/jonathan/.cargo/bin/wasm-pack --version"
        ]

        expand_spec [
            shape=box,
            auto_status=true,
            prompt="You are creating the canonical specification for a Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
1. Check if .ai/spec.md already exists and is adequate:
   - If it exists and covers the scope, deliverables, constraints, and acceptance criteria for this Rogue port, keep it as-is
   - If it's a placeholder or inadequate, proceed to step 2

2. If creating a new spec, examine the original Rogue source structure at demo/rogue/original-rogue/ to understand:
   - The 33 C source files and their organization
   - Core systems: dungeon generation, monster AI, item handling, combat, RNG
   - ncurses I/O patterns that need WASM/JS bridge replacement
   - File I/O patterns that need localStorage replacement

3. Write .ai/spec.md with these sections:
   ## Scope
   - Port Rogue 5.4.4 from C to Rust/WASM
   - Exact mechanical translation (algorithms, stats, tables, formulas)
   - Browser playable via single HTML page

   ## Deliverables
   - demo/rogue/rogue-wasm/www/index.html (playable page)
   - Rust source organized in demo/rogue/rogue-wasm/src/
   - WASM binary compiled from Rust
   - JS glue code for terminal rendering and localStorage

   ## Core Requirements
   ### Faithful Port
   - Same dungeon generation algorithm as original C
   - Same monster stats, AI behavior, and movement
   - Same item tables and effects
   - Same RNG formula
   - Same combat math

   ### Terminal Rendering
   - 80x24 character grid
   - Classic ASCII: @ for player, # for corridors, A-Z for monsters
   - Dark background, monospace font
   - Render via JS terminal emulator

   ### Platform Adaptation
   - Replace ncurses calls with WASM→JS bridge for terminal I/O
   - Replace C file I/O with localStorage for save/load
   - Keyboard input via JS event handlers

   ## Constraints
   - Must preserve exact game mechanics (no gameplay changes)
   - Single-page application (no server required)
   - Must work in modern browsers (Chrome, Firefox, Safari, Edge)

   ## Assumptions
   - Original C source at demo/rogue/original-rogue/ is authoritative
   - Browser has WASM support
   - localStorage available for save files

   ## Non-Goals
   - Not adding new features or game modes
   - Not modernizing graphics (keep ASCII)
   - Not supporting mobile/touch (keyboard only)
   - Not multiplayer or networking

OUTPUT:
Write .ai/spec.md with the above structure. Include the full user-provided goal verbatim in a delimited block:

---BEGIN-VERBATIM-GOAL---
$goal
---END-VERBATIM-GOAL---

Status: This node has auto_status=true. Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback, if you need to report a failure."
        ]

        check_dod [
            shape=box,
            label="DoD exists?",
            prompt="Check if .ai/definition_of_done.md exists and is adequate for the Rogue port project.

GOAL:
$goal

YOUR TASK:
1. Check if .ai/definition_of_done.md exists
2. If it exists, verify it contains:
   - Specific deliverables (HTML page path, Rust source structure)
   - Acceptance criteria for faithful port (dungeon gen, monster AI, combat, RNG, items)
   - Verification approach (how to test mechanical correctness)
   - Build/test requirements
   - Quality gates (formatting, no artifacts, WASM bundle size)
   - Non-goals

3. Determine outcome:
   - If DoD exists and covers all Rogue port requirements → outcome=has_dod
   - If DoD missing or inadequate → outcome=needs_dod

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\",\"outcome\":\"has_dod\"} or {\"status\":\"success\",\"outcome\":\"needs_dod\"}.

Do NOT write nested status.json files after cd commands. Use only the provided status path variables."
        ]
    }

    subgraph cluster_dod {
        label="DoD Fanout"
        node [shape=box]

        dod_fanout [shape=component, label="DoD Fan-Out"]

        dod_a [
            class="branch-a",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_a.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        dod_b [
            class="branch-b",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_b.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        dod_c [
            class="branch-c",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_c.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        consolidate_dod [
            auto_status=true,
            prompt="Synthesize the three DoD proposals (dod_a, dod_b, dod_c) into a single consensus Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/dod_a.md, .ai/dod_b.md, .ai/dod_c.md

2. Read .ai/spec.md for context

3. Create .ai/definition_of_done.md by:
   - Taking the best elements from each branch proposal
   - Resolving any contradictions
   - Ensuring coverage of DoD rubric: scope, deliverables, acceptance criteria, verification, quality gates, non-goals
   - Ensuring coverage checklist: build (cargo/wasm-pack), tests, formatting, browser compatibility, WASM bundle size

4. DoD must be outcomes/evidence based (pass/fail criteria), not implementation steps

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]
    }

    subgraph cluster_planning {
        label="Planning Fanout"
        node [shape=box]

        plan_fanout [shape=component, label="Plan Fan-Out"]

        plan_a [
            class="branch-a",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_a.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        plan_b [
            class="branch-b",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_b.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        plan_c [
            class="branch-c",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_c.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        debate_consolidate [
            auto_status=true,
            prompt="Synthesize the three implementation plans (plan_a, plan_b, plan_c) into a single best-of-breed final plan.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md

2. If .ai/postmortem_latest.md exists, verify the final plan addresses every identified issue

3. Create .ai/plan_final.md by:
   - Taking best approaches from each branch
   - Resolving conflicts between plans
   - Ensuring correct dependency order (RNG before dungeon gen, data structures before algorithms)
   - Covering all DoD deliverables and acceptance criteria
   - Being specific to Rogue port: exact file structure, system organization, WASM/JS interfaces

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]
    }

    subgraph cluster_implement_verify {
        label="Implement And Verify"

        implement_fanout [shape=component, label="Implement Fan-Out"]

        // AC5: RNG algorithm + core type definitions used by all modules
        implement_core_types [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing the core Rust data structures and RNG for Rogue WASM.

**Goal:** $goal

**This module owns:** AC5 (faithful RNG — same seed must produce same sequence), plus core type definitions used by all other modules.

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in core types. Do NOT regenerate working code. Preserve all passing implementations.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Port core C structs from demo/rogue/original-rogue/ to Rust:
- Player (HP, stats, position, inventory, level)
- Monster (type, HP, position, AI state)
- Item (type, position, identified flag, enchantment)
- Level (rooms, corridors, tile map)
- Game state container
- RNG: port exact C rand() algorithm from original source (same seed → same sequence)

**Requirements:**
- Read original C struct definitions from demo/rogue/original-rogue/*.h
- Preserve field names and types (translate C types to Rust equivalents)
- Add serde Serialize/Deserialize derives for save/load
- Add wasm-bindgen annotations where needed for JS interop
- Use idiomatic Rust (Option<T> for nullables, Vec<T> for arrays)

**Deliverables:**
- demo/rogue/rogue-wasm/src/types.rs with all core structs
- demo/rogue/rogue-wasm/src/rng.rs with RNG port
- Cargo.toml with wasm-bindgen and serde dependencies

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_core_types_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        // AC1: rooms + corridors + gold placement
        implement_dungeon_gen [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing dungeon generation for Rogue WASM.

**Goal:** $goal

**This module owns:** AC1 (faithful dungeon generation — same algorithm as original C).

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in dungeon generation. Do NOT regenerate working code.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Port dungeon generation from demo/rogue/original-rogue/ to Rust:
- Room placement algorithm (from rnd_room.c or equivalent)
- Corridor carving (connect rooms via hallways)
- Tile type assignment (floor, wall, door, corridor)
- Monster/gold placement

**Requirements:**
- Read original C code for room generation and corridor logic
- Preserve RNG sequence (port C rand() calls using rng module from types.rs)
- Maintain same probability distributions for room sizes and placement
- Ensure generated levels are fully connected (all rooms reachable)

**Deliverables:**
- demo/rogue/rogue-wasm/src/dungeon.rs with generation functions
- Uses types from src/types.rs

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_dungeon_gen_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        // AC2: pathfinding + AC3: combat resolution
        implement_monster_ai [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing monster AI and combat for Rogue WASM.

**Goal:** $goal

**This module owns:** AC2 (monster AI — all A-Z monsters with original stats, original pathfinding), AC3 (combat resolution — exact damage and hit formulas from original C).

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in monster AI. Do NOT regenerate working code.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Port monster behavior from demo/rogue/original-rogue/ to Rust:
- Monster stats table (HP, damage, armor for each monster type A-Z)
- Pathfinding (chase player when visible)
- Combat formulas (hit chance, damage calculation — MUST match original C exactly)
- Special abilities (if any)
- Monster death and loot drops

**Requirements:**
- Read original C monster data (mon_data.c or rogue.h monster definitions)
- Preserve exact combat math (to-hit rolls, damage dice)
- Match pathfinding behavior (chase logic as in original)
- Ensure monster AI uses same RNG sequence

**Deliverables:**
- demo/rogue/rogue-wasm/src/monster.rs with AI and combat logic
- Uses types from src/types.rs

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_monster_ai_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        // AC4: item types + AC8: pickup/drop/inventory
        implement_items [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing the item system for Rogue WASM.

**Goal:** $goal

**This module owns:** AC4 (item system — all item types with original effects), AC8 (inventory/pickup/drop as precondition for browser playability).

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in item logic. Do NOT regenerate working code.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Port item handling from demo/rogue/original-rogue/ to Rust:
- Item generation (weapons, armor, potions, scrolls, rings, food)
- Item identification system (unidentified vs identified)
- Usage effects (potion effects, scroll effects, weapon/armor bonuses)
- Inventory management (pickup, drop, equip)
- Item drop tables and probabilities

**Requirements:**
- Read original C item tables and effect code
- Preserve item generation probabilities
- Match item effect formulas exactly (healing amounts, stat boosts)
- Maintain identification mechanics

**Deliverables:**
- demo/rogue/rogue-wasm/src/items.rs with generation and effect logic
- Uses types from src/types.rs

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_items_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        // AC6: terminal rendering + status/message lines
        implement_io_bridge [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing the WASM/JS I/O bridge for Rogue WASM.

**Goal:** $goal

**This module owns:** AC6 (terminal rendering — 80x24 ASCII grid, correct chars, dark background), AC8 (browser playability — keyboard input, WASM loading in index.html).

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in I/O bridge. Do NOT regenerate working code.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Replace ncurses calls with WASM bridge to JS terminal renderer:
- Terminal abstraction layer (move cursor, set char, get input)
- WASM-exported functions: game_loop(), handle_input(key), new_game()
- Terminal state buffer (80x24 grid) exposed to JS
- Input event handling (arrow keys, inventory commands)
- Status line and message line rendering

**Requirements:**
- Use wasm-bindgen to export game_loop, handle_input, new_game
- Terminal buffer as static or WASM linear memory accessible from JS
- Map ncurses calls (mvaddch, getch, refresh) to buffer updates
- Handle keyboard input codes (arrow keys, inventory commands)
- CSS: dark background, monospace font; ASCII: @ player, # corridors, + doors, . floor, | - walls, A-Z monsters

**Deliverables:**
- demo/rogue/rogue-wasm/src/io.rs with terminal abstraction
- demo/rogue/rogue-wasm/src/lib.rs with wasm-bindgen exports
- demo/rogue/rogue-wasm/www/index.html with JS terminal renderer

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_io_bridge_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        // AC7: save/load persistence via localStorage
        implement_save_load [
            shape=box,
            class="hard",
            auto_status=true,
            max_retries=2,
            prompt="You are implementing save/load for Rogue WASM.

**Goal:** $goal

**This module owns:** AC7 (save/load — localStorage persists and restores exact game state).

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY the identified gaps in save/load. Do NOT regenerate working code.

**FRESH MODE:** If no postmortem exists, implement from .ai/plan_final.md.

**Module Scope:**
Replace filesystem save/load with localStorage:
- Serialize entire game state to JSON (serde_json)
- WASM-exported functions: save_game(), load_game()
- JS bridge to localStorage.setItem / getItem
- Handle save/load errors gracefully

**Requirements:**
- Use serde to serialize game state (Player, Level, Monsters, Items)
- Export save_game() and load_game() via wasm-bindgen
- JS code calls these and stores result in localStorage
- Verify deserialization round-trips correctly

**Deliverables:**
- demo/rogue/rogue-wasm/src/save.rs with serialization logic
- Updated src/lib.rs with save_game/load_game exports
- Updated www/index.html with save/load button handlers

**Logging:**
Append progress to .ai/implementation_log.md

**Write implementation notes to .ai/module_save_load_impl.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed items>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        merge_implementation [
            shape=box,
            auto_status=true,
            max_retries=2,
            prompt="You are integrating all Rogue WASM modules and resolving conflicts.

**Goal:** $goal

**REPAIR MODE CHECK:** If .ai/postmortem_latest.md exists, read it FIRST. Fix ONLY integration issues. Do NOT regenerate working modules.

**FRESH MODE:** If no postmortem exists, integrate from module outputs.

**Module Integration:**
1. Read implementation notes from:
   - .ai/module_core_types_impl.md
   - .ai/module_dungeon_gen_impl.md
   - .ai/module_monster_ai_impl.md
   - .ai/module_items_impl.md
   - .ai/module_io_bridge_impl.md
   - .ai/module_save_load_impl.md

2. Integrate modules into cohesive game:
   - Main game loop in src/lib.rs calls dungeon gen, monster AI, item handling
   - I/O bridge renders game state to terminal buffer
   - Save/load serializes full state
   - All modules compile together

3. Resolve conflicts:
   - Ensure module interfaces match (types, function signatures)
   - Fix circular dependencies
   - Add missing glue code

4. Progressive compilation:
   - Compile after each integration step
   - Fix errors before continuing

**Deliverables:**
- demo/rogue/rogue-wasm/src/lib.rs with main game loop
- demo/rogue/rogue-wasm/Cargo.toml with all dependencies
- All modules compiling together

**Logging:**
Append integration progress to .ai/implementation_log.md

**Write integration notes to .ai/merge_implementation.md**

Write your status to $KILROY_STAGE_STATUS_PATH, with $KILROY_STAGE_STATUS_FALLBACK_PATH as fallback.

On success: {\"status\": \"success\"}
On failure: {\"status\": \"fail\", \"failure_reason\": \"<reason>\", \"details\": \"<details>\", \"failure_class\": \"deterministic_agent_bug\", \"failure_signature\": \"<sorted comma-separated list of failed integration points>\"}

Do NOT write {\"status\": \"retry\"} — use custom outcomes for iteration."
        ]

        check_implement [shape=diamond, label="Merge OK?"]

        fix_fmt [
            shape=parallelogram,
            max_retries=0,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo fmt"
        ]

        verify_fmt [
            shape=parallelogram,
            max_retries=0,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo fmt --check"
        ]
        check_fmt [shape=diamond, label="Fmt OK?"]

        verify_build [
            shape=parallelogram,
            tool_command="scripts/wasm-build.sh demo/rogue/rogue-wasm"
        ]
        check_build [shape=diamond, label="Build OK?"]

        verify_test [
            shape=parallelogram,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo test && test -f www/index.html && test -f www/pkg/rogue_wasm.js && test -f www/pkg/rogue_wasm_bg.wasm"
        ]
        check_test [shape=diamond, label="Tests OK?"]

        verify_artifacts [
            shape=parallelogram,
            max_retries=0,
            tool_command="! find demo/rogue/rogue-wasm -type d \\( -name '.cargo-target*' -o -name '.cargo_target*' \\) | grep -q ."
        ]
        check_artifacts [shape=diamond, label="Artifacts OK?"]

        verify_fidelity [
            shape=box,
            class="verify",
            prompt="Verify the Rogue port implementation against the Definition of Done.

GOAL:
$goal

**AC-to-module ownership (for blame attribution):**
- AC1: Dungeon Generation → implement_dungeon_gen (src/dungeon.rs)
- AC2: Monster AI        → implement_monster_ai  (src/monster.rs)
- AC3: Combat System     → implement_monster_ai  (src/monster.rs or src/combat.rs)
- AC4: Item System       → implement_items       (src/items.rs)
- AC5: RNG/Core Types    → implement_core_types  (src/rng.rs, src/types.rs)
- AC6: Terminal Rendering → implement_io_bridge  (src/io.rs, www/index.html)
- AC7: Save/Load         → implement_save_load   (src/save.rs)
- AC8: Browser Playability → implement_io_bridge (www/index.html, src/lib.rs)

YOUR TASK:
1. Read .ai/definition_of_done.md and .ai/spec.md

2. Verify each acceptance criterion:

   **AC1: Faithful Port - Dungeon Generation**
   - Check: Does src/dungeon.rs implement the same room placement algorithm as original C?
   - Check: Are corridors generated identically?
   - Check: Are doors placed using the same logic?
   - Evidence: Read src/dungeon.rs and compare to demo/rogue/original-rogue/ dungeon generation code

   **AC2: Faithful Port - Monster AI**
   - Check: Are all monsters A-Z present in src/monster.rs?
   - Check: Do monster stats match original C tables?
   - Check: Does pathfinding match original behavior?
   - Evidence: Read src/monster.rs and compare to original monster code

   **AC3: Faithful Port - Combat System**
   - Check: Does damage calculation match original formula?
   - Check: Do hit/miss mechanics match original?
   - Evidence: Read combat logic and compare to original combat code

   **AC4: Faithful Port - Item System**
   - Check: Are all item types present in src/items.rs?
   - Check: Do item effects match original?
   - Evidence: Read src/items.rs and compare to original item code

   **AC5: Faithful Port - RNG**
   - Check: Does src/rng.rs use the same RNG algorithm as original C?
   - Check: Does same seed produce same sequence?
   - Evidence: Read src/rng.rs and compare to original RNG code

   **AC6: Terminal Rendering**
   - Check: Does www/index.html implement 80x24 grid?
   - Check: Are ASCII characters correct (@ player, # corridors, A-Z monsters, etc.)?
   - Check: Is background dark and font monospace?
   - Evidence: Read www/index.html and verify rendering code

   **AC7: Save/Load**
   - Check: Does src/save.rs implement localStorage save/load?
   - Check: Is game state fully serialized and round-trip verified?
   - Evidence: Read src/save.rs

   **AC8: Browser Playability**
   - Check: Does index.html load WASM correctly?
   - Check: Is keyboard input wired up?
   - Check: Are game_loop, handle_input, save_game, load_game, new_game exported?
   - Evidence: Read www/index.html and verify JS glue code

3. Write detailed verification results to .ai/verify_fidelity.md:
   - List each AC with PASS/FAIL status
   - Provide specific evidence for each
   - If any AC fails, name the owning module

**failure_signature format:** comma-separated list of failing AC IDs, uppercase, no spaces — e.g. \"AC1,AC3,AC7\". Include exactly the ACs that have NOT been met.

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable):
- All ACs pass: {\"status\":\"success\",\"outcome\":\"pass\"}
- Some ACs fail: {\"status\":\"success\",\"outcome\":\"fail\",\"failure_signature\":\"AC1,AC3\"}
- Agent/tool crash: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"transient_infra\"}"
        ]
        check_impl [shape=diamond, label="Impl OK?"]
    }

    subgraph cluster_review {
        label="Review Fanout"
        node [shape=box]

        review_fanout [shape=component, label="Review Fan-Out"]

        review_a [
            class="branch-a",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_a.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable):
- APPROVED: {\"status\":\"success\",\"outcome\":\"approved\"}
- REJECTED: {\"status\":\"success\",\"outcome\":\"rejected\",\"failure_signature\":\"AC1,AC3\"}
- Agent/tool crash: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"transient_infra\"}"
        ]

        review_b [
            class="branch-b",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_b.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable):
- APPROVED: {\"status\":\"success\",\"outcome\":\"approved\"}
- REJECTED: {\"status\":\"success\",\"outcome\":\"rejected\",\"failure_signature\":\"AC1,AC3\"}
- Agent/tool crash: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"transient_infra\"}"
        ]

        review_c [
            class="branch-c",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_c.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable):
- APPROVED: {\"status\":\"success\",\"outcome\":\"approved\"}
- REJECTED: {\"status\":\"success\",\"outcome\":\"rejected\",\"failure_signature\":\"AC1,AC3\"}
- Agent/tool crash: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"transient_infra\"}"
        ]

        review_consensus [
            auto_status=true,
            goal_gate=true,
            prompt="Synthesize the three reviews (review_a, review_b, review_c) into a consensus verdict.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/review_a.md, .ai/review_b.md, .ai/review_c.md

2. Read .ai/definition_of_done.md for criteria

3. Apply consensus rule:
   - If 2+ reviews are APPROVED with no critical gaps → **SUCCESS**
   - If 1 or fewer APPROVED, or critical gaps identified → **REJECTED** with specific issues

4. Write .ai/review_consensus.md with:
   - **Consensus Verdict**: SUCCESS or REJECTED
   - **Summary**: What passed, what needs fixing
   - If REJECTED: Specific issues to address (with AC identifiers)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable):
- SUCCESS: {\"status\":\"success\",\"outcome\":\"success\"}
- REJECTED: {\"status\":\"success\",\"outcome\":\"rejected\"}

Do NOT use {\"status\":\"fail\"} for rejection — that blocks goal_gate re-execution."
        ]
    }

    subgraph cluster_postmortem {
        label="Postmortem"
        node [shape=box]

        postmortem [
            auto_status=true,
            prompt="Analyze the implementation failure and guide the next repair iteration.

GOAL:
$goal

YOUR TASK:
1. Read failure context:
   - If review stage reached: read .ai/review_consensus.md
   - If semantic verify ran: read .ai/verify_fidelity.md
   - If branch reviews available: check parallel_results.json + worktree_dir for .ai/review_a.md, .ai/review_b.md, .ai/review_c.md
   - Read .ai/implementation_log.md

2. Identify:
   - **Root causes**: Why did implementation fail?
   - **What worked**: Which systems are passing? (PRESERVE THESE)
   - **What failed**: Which systems/ACs failed? (FIX THESE)
   - **Concrete next changes**: Specific repairs needed

3. Classify failure for recovery routing:
   - **impl_repair**: Code needs fixing, plan/toolchain still valid (DEFAULT)
   - **needs_replan**: Plan/approach is fundamentally inadequate
   - **needs_toolchain**: Environment/toolchain issue detected

4. Write .ai/postmortem_latest.md (overwrite previous) with:
   - Root cause analysis
   - What to preserve (passing code)
   - What to fix (specific modules/functions)
   - Concrete repair instructions

**CRITICAL**: DO NOT direct from-scratch restart. Preserve working code.

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- {\"status\":\"success\",\"outcome\":\"impl_repair\"} (default, code repair needed)
- {\"status\":\"success\",\"outcome\":\"needs_replan\"} (plan inadequate)
- {\"status\":\"success\",\"outcome\":\"needs_toolchain\"} (toolchain issue)

Note: status=success means postmortem analysis completed successfully, NOT that implementation succeeded."
        ]
    }

    // Flow
    start -> check_toolchain
    check_toolchain -> expand_spec [condition="outcome=success"]
    check_toolchain -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain -> postmortem
    expand_spec -> check_dod

    check_dod -> dod_fanout [condition="outcome=needs_dod"]
    check_dod -> dod_fanout
    dod_fanout -> dod_a
    dod_fanout -> dod_b
    dod_fanout -> dod_c
    dod_a -> consolidate_dod
    dod_b -> consolidate_dod
    dod_c -> consolidate_dod
    consolidate_dod -> plan_fanout

    check_dod -> plan_fanout [condition="outcome=has_dod"]

    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement_fanout

    implement_fanout -> implement_core_types
    implement_fanout -> implement_dungeon_gen
    implement_fanout -> implement_monster_ai
    implement_fanout -> implement_items
    implement_fanout -> implement_io_bridge
    implement_fanout -> implement_save_load

    implement_core_types -> merge_implementation
    implement_dungeon_gen -> merge_implementation
    implement_monster_ai -> merge_implementation
    implement_items -> merge_implementation
    implement_io_bridge -> merge_implementation
    implement_save_load -> merge_implementation

    merge_implementation -> check_implement
    check_implement -> fix_fmt [condition="outcome=success"]
    fix_fmt -> verify_fmt
    check_implement -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem           [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem
    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem           [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test        [condition="outcome=success"]
    check_build -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem         [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_artifacts    [condition="outcome=success"]
    check_test -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem          [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity  [condition="outcome=success"]
    check_artifacts -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem       [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_artifacts -> postmortem

    verify_fidelity -> check_impl
    check_impl -> review_fanout [condition="outcome=pass"]
    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    check_impl -> merge_implementation [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_impl -> postmortem           [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_impl -> postmortem

    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem

    postmortem -> check_toolchain    [condition="outcome=fail && context.failure_class=transient_infra"]
    postmortem -> implement_fanout   [condition="outcome=impl_repair"]
    postmortem -> plan_fanout        [condition="outcome=needs_replan"]
    postmortem -> check_toolchain    [condition="outcome=needs_toolchain"]
    postmortem -> implement_fanout
}